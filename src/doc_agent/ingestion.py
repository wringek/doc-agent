# src/agent/ingestion.py

import sys
import re
from pathlib import Path
from typing import Optional, List, Dict


def ingest(path: Optional[str] = None) -> Dict[str, object]:
    """
    Read a file (or stdin), strip comments for the clean source,
    parse JSDoc comments for parameters and return types,
    and extract the function name.
    The 'summary' field is left empty and will be generated by the LLM.

    Returns:
        dict: {
            'name': function name or filename,
            'summary': '',
            'params': list of parameter metadata dicts,
            'returns': return metadata dict,
            'source': cleaned source code without comments
        }
    """
    # 1. Read the raw text from file or stdin
    text = Path(path).read_text() if path else sys.stdin.read()

    # 2. Initialize containers for parsed JSDoc metadata
    params: List[Dict[str, str]] = []
    returns: Dict[str, str] = {}

    # 3. Locate the JSDoc comment block (/** ... */) if present
    jsdoc_match = re.search(r'/\*\*([\s\S]*?)\*/', text)
    if jsdoc_match:
        # Extract inner contents of the JSDoc block
        block = jsdoc_match.group(1)
        # Iterate each line to find @param and @returns tags
        for line in block.splitlines():
            # @param {type} name – description
            p = re.match(r'\s*\*\s*@param\s*\{([^}]+)\}\s+(\w+)\s*–\s*(.+)', line)
            if p:
                params.append({
                    "type": p.group(1).strip(),
                    "name": p.group(2).strip(),
                    "description": p.group(3).strip()
                })
                continue
            # @return[s] {type} description
            r = re.match(r'\s*\*\s*@returns?\s*\{([^}]+)\}\s*(.+)', line)
            if r:
                returns = {
                    "type": r.group(1).strip(),
                    "description": r.group(2).strip()
                }

    # 4. Clean the source by removing all block and line comments
    clean = re.sub(r'/\*[\s\S]*?\*/|//.*', '', text).strip()

    # 5. Extract the function name (JavaScript 'function name(' syntax)
    name_match = re.search(r'function\s+([A-Za-z_]\w*)\s*\(', text)
    # Fallback to filename if no function declaration is found
    name = name_match.group(1) if name_match else Path(path or "").stem

    # 6. Return the structured metadata and cleaned source
    return {
        "name":    name,
        "summary": "",     # will be generated by the LLM
        "params":  params,
        "returns": returns,
        "source":  clean
    }
